{
  "_args": [
    [
      {
        "raw": "navigo@^4.7.1",
        "scope": null,
        "escapedName": "navigo",
        "name": "navigo",
        "rawSpec": "^4.7.1",
        "spec": ">=4.7.1 <5.0.0",
        "type": "range"
      },
      "C:\\Users\\Yanakieva\\Desktop\\SPA_MUSIC_FINAL\\Music-SPA-project"
    ]
  ],
  "_from": "navigo@>=4.7.1 <5.0.0",
  "_id": "navigo@4.7.1",
  "_inCache": true,
  "_location": "/navigo",
  "_nodeVersion": "6.7.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/navigo-4.7.1.tgz_1493757467869_0.8416344011202455"
  },
  "_npmUser": {
    "name": "krasimir",
    "email": "krasimir@outset.ws"
  },
  "_npmVersion": "3.10.3",
  "_phantomChildren": {},
  "_requested": {
    "raw": "navigo@^4.7.1",
    "scope": null,
    "escapedName": "navigo",
    "name": "navigo",
    "rawSpec": "^4.7.1",
    "spec": ">=4.7.1 <5.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/navigo/-/navigo-4.7.1.tgz",
  "_shasum": "8b28980c0a1cc12e255656cd962c9c6cc5cd111c",
  "_shrinkwrap": null,
  "_spec": "navigo@^4.7.1",
  "_where": "C:\\Users\\Yanakieva\\Desktop\\SPA_MUSIC_FINAL\\Music-SPA-project",
  "author": {
    "name": "Krasimir Tsonev",
    "email": "info@krasimirtsonev.com",
    "url": "http://krasimirtsonev.com"
  },
  "bugs": {
    "url": "https://github.com/krasimir/navigo/issues"
  },
  "dependencies": {},
  "description": "A simple vanilla JavaScript router with a fallback for older browsers",
  "devDependencies": {
    "babel": "6.3.26",
    "babel-core": "6.4.5",
    "babel-eslint": "6.1.2",
    "babel-loader": "6.2.1",
    "babel-plugin-add-module-exports": "0.1.2",
    "babel-preset-es2015": "6.3.13",
    "babel-preset-stage-1": "6.3.13",
    "babelify": "7.3.0",
    "browserify": "13.1.1",
    "chai": "3.5.0",
    "eslint": "1.10.3",
    "eslint-loader": "1.2.1",
    "karma": "1.3.0",
    "karma-browserify": "5.1.0",
    "karma-chrome-launcher": "2.0.0",
    "karma-firefox-launcher": "1.0.0",
    "karma-mocha": "1.2.0",
    "karma-mocha-reporter": "2.2.0",
    "karma-phantomjs-launcher": "1.0.2",
    "karma-source-map-support": "1.2.0",
    "mocha": "2.4.5",
    "sinon": "1.17.3",
    "sinon-chai": "2.8.0",
    "watchify": "3.7.0",
    "webpack": "1.12.12"
  },
  "directories": {},
  "dist": {
    "shasum": "8b28980c0a1cc12e255656cd962c9c6cc5cd111c",
    "tarball": "https://registry.npmjs.org/navigo/-/navigo-4.7.1.tgz"
  },
  "gitHead": "176bfd423421af8ff9a2ece0f44d6c4011a958ad",
  "homepage": "https://github.com/krasimir/navigo#readme",
  "jsnext:main": "src/index.js",
  "keywords": [
    "router",
    "vanilla",
    "hash",
    "history"
  ],
  "license": "MIT",
  "main": "lib/navigo.js",
  "maintainers": [
    {
      "name": "krasimir",
      "email": "krasimir@outset.ws"
    }
  ],
  "name": "navigo",
  "optionalDependencies": {},
  "readme": "# Navigo\n\nA simple minimalistic JavaScript router with a fallback for older browsers.\n\n![Travis](https://travis-ci.org/krasimir/navigo.svg?branch=master)\n[![npm downloads](https://img.shields.io/npm/dm/navigo.svg?style=flat-square)](https://www.npmjs.com/package/navigo)\n\n*([Demo source files](./demo))*\n\n---\n\n## Installation\n\nVia npm with `npm install navigo` or drop `lib/navigo.min.js` into your page.\n\n## Usage\n\n### Initialization\n\n```js\nvar root = null;\nvar useHash = true; // Defaults to: false\nvar hash = '#!'; // Defaults to: '#'\nvar router = new Navigo(root, useHash, hash);\n```\n\nThe constructor of the library accepts three argument - `root`, `useHash` and `hash`. The first one is the main URL of\nyour application. If you call the constructor without parameters then Navigo figures out the root URL based on your routes.\n\nIf `useHash` set to `true` then the router uses an old routing approach with hash in the URL. Navigo anyways falls back\nto this mode if there is no History API supported. The `hash` parameter allows you to configure the hash character. To\nmake your URLs crawlable by Google you should use use '#!'. Read more at [developers.google.com](https://developers.google.com/webmasters/ajax-crawling/docs/learn-more).\n\n### Adding a route\n\n```js\nrouter\n  .on('/products/list', function () {\n    // display all the products\n  })\n  .resolve();\n```\n\n### Adding a main/root handler\n\n```js\nrouter\n  .on(function () {\n    // show home page here\n  })\n  .resolve();\n```\n\n### Adding multiple routes\n\n```js\nrouter\n  .on({\n    '/products/list': function () { ... },\n    '/products': function () { ... },\n    ...\n  })\n  .resolve();\n```\n\nThe order of routes adding do matter. The URL which is added earlier and matches wins. For example:\n\n```js\nrouter\n  .on({\n    'products/:id': function () {\n      setContent('Products');\n    },\n    'products': function () {\n      setContent('About');\n    },\n    '*': function () {\n      setContent('Home')\n    }\n  })\n  .resolve();\n```\n\n* Have in mind that the order of the added routes using this method [does not](https://github.com/krasimir/navigo/pull/39) matter anymore. However, if we add series of routes by calling `on` multiple times we should consider the order of the calls.\n\n### Parameterized URLs:\n\n```js\nrouter\n  .on('/user/:id/:action', function (params) {\n    // If we have http://site.com/user/42/save as a url then\n    // params.id = 42\n    // params.action = save\n  })\n  .resolve();\n```\n\n### Accessing GET parameters\n\nEvery handler receives the GET parameters passed to the page.\n\n```js\nrouter\n  .on('/user/:id/:action', function (params, query) {\n    // If we have http://site.com/user/42/save?answer=42 as a url then\n    // params.id = 42\n    // params.action = save\n    // query = answer=42\n  })\n  .resolve();\n```\n\nIn the case of the default handler and `notFound` handler the function receives only `query` as parameter. For example:\n```js\nrouter.notFound(function (query) {\n  // ...\n});\n```\n\n### Using regular expression\n\n```js\nrouter\n  .on(/users\\/(\\d+)\\/(\\w+)\\/?/, function (id, action) {\n    // If we have http://site.com/user/42/save as a url then\n    // id = 42\n    // action = save\n  })\n  .resolve();\n```\n\nWild card is also supported:\n\n```js\nrouter\n  .on('/user/*', function () {\n    // This function will be called on every\n    // URL that starts with /user\n  })\n  .resolve();\n```\n\n*Have in mind that every call of `on` do not trigger a route check (anymore). You have to run `resolve` method manually to get the routing works.*\n\n### Not-found handler\n\n```js\nrouter.notFound(function () {\n  // called when there is path specified but\n  // there is no route matching\n});\n```\n\n### Changing the page\n\nUse the `navigate` method:\n\n```js\nrouter.navigate('/products/list');\n```\n\nYou may also specify an absolute path. For example:\n\n```js\nrouter.navigate('http://site.com/products/list', true);\n```\n\nIf you want to bind page links to Navigo you have to add `data-navigo` attribute. For example:\n\n```html\n<a href=\"about\" data-navigo>About</a>\n```\n\n*(Have in mind that you have to fire `updatePageLinks` every time when new links are placed on the page so Navigo does the binding for them.)*\n\nIt's translated to:\n\n```js\n// the html to: <a href=\"javascript:void(0);\" data-navigo>About</a>\nvar location = link.getAttribute('href');\n...\nlink.addEventListener('click', e => {\n  e.preventDefault();\n  router.navigate(location);\n});\n```\n\n### Named routes\n\nUse the following API to give a name to your route and later generate URLs:\n\n```js\nrouter = new Navigo('http://site.com/', true);\nrouter.on({\n  '/trip/:tripId/edit': { as: 'trip.edit', uses: handler },\n  '/trip/save': { as: 'trip.save', uses: handler },\n  '/trip/:action/:tripId': { as: 'trip.action', uses: handler }\n});\nconsole.log(router.generate('trip.edit', { tripId: 42 })); // --> /trip/42/edit\nconsole.log(router.generate('trip.action', { tripId: 42, action: 'save' })); // --> /trip/save/42\nconsole.log(router.generate('trip.save')); // --> /trip/save\n```\n\n### Resolving the routes\n\nThe resolving of the routes happen when `resolve` method is fired which happen:\n\n* if you manually run `router.resolve()`\n* every time when the page's URL changes\n* if you call `navigate`\n\n### Pausing the router\n\n[Sometimes](https://github.com/krasimir/navigo/issues/18) you need to update the URL but you don't want to resolve your callbacks. In such cases you may call `.pause()` and do `.navigate('new/url/here')`. For example:\n\n```js\nr.pause();\nr.navigate('/en/products');\nr.resume(); // or .pause(false)\n```\n\nThe route will be changed to `/en/products` but if you have a handler for that path will not be executed.\n\n### Hooks\n\nThere is an API that allows you to run functions before firing a route handler. The `hooks` object is in the format of:\n\n```js\n{\n  before: function (done, params) { ... done(); },\n  after: function (params) { ... }\n}\n```\n\nYou may specify only one (or both) hooks. The `before` hook accepts a function which you *must* invoke once you finish your job. Here is an examples:\n\n```js\nrouter.on(\n  '/user/edit',\n  function () {\n    // show user edit page\n  },\n  {\n    before: function (done, params) {\n      // doing some async operation\n      done();\n    },\n    after: function (params) {\n      console.log('Data saved.');\n    }\n  }\n);\n```\n\nYou may prevent the handler to be resolved in the `before` hook by invoking `done(false)`:\n\n```js\nrouter.on(\n  '/user/edit',\n  function () {\n    // show user edit page\n  },\n  {\n    before: function (done, params) {\n      if(!user.loggedIn) {\n        done(false);\n      } else {\n        done()\n      }\n    }\n  }\n);\n```\n\nYou may provide hooks in two other cases:\n\n* While specifying a main/root handler `router.on(function() { ... }, hooks)`\n* While specifying a not-found page handler `router.notFound(function() { ... }, hooks)`\n\n*Also notice that both hooks receive `params` in case they are attached to a parameterized route.*\n\n## API\n\n* `router.on(function)` - adding handler for root/main route\n* `router.on(string, function)` - adding a new route\n* `router.on(object)` - adding a new route\n* `router.off(handler)` - removes the routes associated with the given handler/function\n* `router.navigate(path='', absolute=false)` - if `absolute` is `false` then Navigo finds the root path of your app based on the provided routes.\n* `router.resolve(currentURL=undefined)` - if `currentURL` is provided then the method tries resolving the registered routes to that URL and not `window.location.href`.\n* `router.destroy` - removes all the registered routes and stops the URL change listening.\n* `router.link(path)` - it returns a full url of the given `path`\n* `router.pause(boolean)` - it gives you a chance to change the route without resolving. Make sure that you call `router.pause(false)` so you return to the previous working state.\n* `router.disableIfAPINotAvailable()` - well, it disables the route if History API is not supported\n* `router.updatePageLinks()` - it triggers the `data-navigo` links binding process\n* `router.notFound(function)` - adding a handler for not-found URL (404 page)\n* `router.lastRouteResolved()` - returns an object with the format of `{ url: <string>, query: <string> }` matching the latest resolved route\n* `router.getLinkPath` - you may overwrite that function to provide a different mechanism for fetching paths from links which are currently on the page (with `data-navigo` attribute)\n\nThere are couple of static properties. You'll probably never need to touch them but here're they:\n\n```js\nNavigo.PARAMETER_REGEXP = /([:*])(\\w+)/g;\nNavigo.WILDCARD_REGEXP = /\\*/g;\nNavigo.REPLACE_VARIABLE_REGEXP = '([^\\/]+)';\nNavigo.REPLACE_WILDCARD = '(?:.*)';\nNavigo.FOLLOWED_BY_SLASH_REGEXP = '(?:\\/$|$)';\nNavigo.MATCH_REGEXP_FLAGS = '';\n```\n\n`Navigo.MATCH_REGEXP_FLAGS` could be useful when you want a case insensitive route matching. Simple use `Navigo.MATCH_REGEXP_FLAGS = 'i'`.\n\n## Tests\n\n```\nnpm i\nnpm test\n// or npm run test-chrome\n// or npm run test-firefox\n```\n\n## Inspiration\n\n* [A modern JavaScript router in 100 lines](http://krasimirtsonev.com/blog/article/A-modern-JavaScript-router-in-100-lines-history-api-pushState-hash-url)\n\n## TODO\n\n* A general handler for when Navigo matches some of the rules\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/krasimir/navigo.git"
  },
  "scripts": {
    "build": "WEBPACK_ENV=build ./node_modules/.bin/webpack",
    "dev": "WEBPACK_ENV=dev ./node_modules/.bin/webpack --progress --colors --watch",
    "test": "node ./test/karma.js",
    "test-chrome": "node ./test/karma.js --browser=Chrome --watch=true",
    "test-firefox": "node ./test/karma.js --browser=Firefox  --watch=true"
  },
  "version": "4.7.1"
}
